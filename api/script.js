// BASE CODE FROM: https://github.com/betfair/API-NG-sample-code/blob/master/javascript/JsonRpcApiNgClient.js


// Objectives
/*
  • Send a call from front-end to back-end
  • Find how to make api requests - Tutorials
  • Functions for Maths - Possibly ask Janka
*/

// Calculation for bankroll stake percentage
// If result is above 0, then value is identified
/*
[(Probability x odds) – 1] / (odds-1)
Example: [(0.35 * 2.4) - 1] / 1.4


Taking match odds on a football match as an example, there are three possible results
home win,
away win or
draw.

Assuming the game is priced as follows:

Home win = 1.75 (57.14%)
Away win = 3.9 (25.64%)
Draw = 3.5 (28.57%)
Logically the result of an event can only be 100%,
but we can see here that by adding up the probabilities (in brackets)
we actually arrive at a total of 111.35% this extra 11.35% is called the overround,
it is the profit that the bookmaker is expecting to make on this event and is
generated by offering worse odds on the event than the actual true odds.


11/4
15 games
  home team win = 11/15 = 73%
  home team no win = 4/15 = 27%

*/



// USING 'response.result' finally displayed the correct data - I was missing '.result'



var https = require('https');

// Start the app
MyApplication();

// Main class that contains all operations
function MyApplication(){

// Retrieve command line args
//var myArgs = process.argv.slice(2);

// App key
var appkey = 'qEH0EjenDr5sEgx2';
// Session token
var ssid = 'Jr+8fgvIAedrFVf7pDCKZEZZpmSXlxKI/89dRzAc4Bw=';

// Data Variables
var FIRST_INDEX = 0;
var DEFAULT_ENCODING = 'utf-8';
var DEFAULT_JSON_FORMAT = '\t';

var options = {
    hostname: 'api.betfair.com',
    port: 443,
    path: '/exchange/betting/json-rpc/v1',
    method: 'POST',
    headers: {
        'X-Application' : appkey,
        'Accept': 'application/json',
        'Content-type' : 'application/json',
        'X-Authentication' : ssid
        }
    }

    start();

	// Start from finding the horse race event type id
    function start() {
      findSoccerMatchId(options);
    }

	// Construct request and POST it to API-NG
    function findSoccerMatchId(options) {
		console.log("Get soccer event id");
		// Define soccer in filter object
        var requestFilters = '{"filter":{}}';
        var jsonRequest = constructJsonRpcRequest('listEventTypes', requestFilters );
        var str = '';
        var req = https.request(options, function (res) {
            res.setEncoding(DEFAULT_ENCODING);
            res.on('data', function (chunk) {
                str += chunk; // Chunk of Data adds to string varible
            });
            res.on('end', function (chunk) {
                // On response parse Json and check for errors
                var response = JSON.parse(str);
                handleError(response);

                console.log(response.result);
                //console.log('SHOWING SOCCER IN EVENT LIST');
                //console.log(response.result[FIRST_INDEX]);

                getPremierLeagueMatch(options, response);

                // Retrieve id from response and get next available horse race
                //getNextAvailableSoccerMatch(options, response);
            });

        });
        // Send Json request object
        req.write(jsonRequest, DEFAULT_ENCODING);
        req.end();

        req.on('error', function(e) {
            console.log('Problem with request: ' + e.message);
        });
    }










    function getPremierLeagueMatch(options, response) {

        // Retrieve event id from previous response
        var eventTypeId = retrieveEventId(response);
        var jsonDate = new Date().toJSON();
        var compID = retrieveCompId(response);

        var str = '';
        var requestFilters = '{"filter" : {"eventTypeIds": [' + eventTypeId + '], "competitionIds" : [' + compId + ']}, "maxResults" : "10" }';

        var jsonRequest = constructJsonRpcRequest('listCompetitions', requestFilters );
        var req = https.request(options, function (res){
            res.setEncoding(DEFAULT_ENCODING);
            res.on('data', function (chunk) {
                str += chunk;
            });

            res.on('end', function (chunk) {
                var response = JSON.parse(str);

                handleError(response);

            });
        });
        req.write(jsonRequest, DEFAULT_ENCODING);
        req.end();
        req.on('error', function(e) {
            console.log('Problem with request: ' + e.message);
        });
    }
    //var compId = 31; // Competition - Premier League ID












	  // Get next Soccer match based on current date
    function getNextAvailableSoccerMatch(options, response) {

        // Retrieve event id from previous response
        var eventId = retrieveEventId(response);
        var jsonDate = new Date().toJSON();
        //var compId = retrieveCompId(response);

        console.log("Get next available soccer match starting from date: " + jsonDate);
        var str = '';
        //var requestFilters = '{"filter" : {"eventTypeIds": [' + eventId + '], "competitionIds" : [' + compId + ']}, "maxResults" : "10" }';
        //var requestFilters = '{"filter":{"eventTypeIds": [' + eventId + '],"marketCountries":["GB"],"marketTypeCodes":["WIN"],"marketStartTime":{"from":"'+jsonDate+'"}},"sort":"FIRST_TO_START","maxResults":"1","marketProjection":["RUNNER_DESCRIPTION"]}';
        //var jsonRequest = constructJsonRpcRequest('listMarketCatalogue', requestFilters );
        var jsonRequest = constructJsonRpcRequest('listEvents', requestFilters );
        var req = https.request(options, function (res){
            res.setEncoding(DEFAULT_ENCODING);
            res.on('data', function (chunk) {
                str += chunk;
            });

            res.on('end', function (chunk) {
                var response = JSON.parse(str);

                // console logging the first event in results
                console.log(response.result[FIRST_INDEX].event);

                handleError(response);

                // Get list of runners that are available in that match
                //getListOfRunners(options, response);
            });
        });
        req.write(jsonRequest, DEFAULT_ENCODING);
        req.end();
        req.on('error', function(e) {
            console.log('Problem with request: ' + e.message);
        });
    }


    // FIX THIS FUNCTION - Possibly listmarketBook
    function getListOfRunners(options, response){

        var x = response.result[FIRST_INDEX].event['id'];

        //console.log(response.result[0].event['id']);
        //var eventId = retrieveEventId(response);
        var marketId = retrieveMarketId(response); //1.129585910; //1.124873291 //retrieveMarketId(response);
        var jsonDate = new Date().toJSON();
        console.log("Get list of runners for market Id: " + marketId);
        var requestFilters = '{"marketIds":["' + marketId + '"],"priceProjection":{"priceData":["EX_BEST_OFFERS"],"exBestOfferOverRides":{"bestPricesDepth":2,"rollupModel":"STAKE","rollupLimit":20},"virtualise":false,"rolloverStakes":false},"orderProjection":"ALL","matchProjection":"ROLLED_UP_BY_PRICE"}}';
        //var requestFilters = '{"marketIds": [' + marketId + '],"marketCountries":["GB"],"marketTypeCodes":["WIN"],"marketStartTime" : {"from":"'+ jsonDate +'"},"sort":"FIRST_TO_START","maxResults":"1","marketProjection":["RUNNER_DESCRIPTION"]}';

        // Original Filter
        //var requestFilters = '{"filter":{"eventTypeIds": [' + eventId + '],"marketCountries":["GB"],"marketTypeCodes":["WIN"],"marketStartTime":{"from":"'+jsonDate+'"}},"sort":"FIRST_TO_START","maxResults":"1","marketProjection":["RUNNER_DESCRIPTION"]}}';
        var jsonRequest = constructJsonRpcRequest('listMarketCatalogue', requestFilters );
        var str = '';
        var req = https.request(options,function (res){
            res.setEncoding(DEFAULT_ENCODING);
            res.on('data', function (chunk) {
                str += chunk;
            });

            res.on('end', function (chunk) {
                var response = JSON.parse(str);
                console.log(response);
                handleError(response);

                //console.log(response.result[0]); //.selectionId);
                //console.log(response.result[0].runners[0].runnersName);
                //console.log(response.result[0].runners[0].lastPriceTraded);
                // Place bet on first runner
              //  placeBet(options, response, marketId);
            });
        });
        req.write(jsonRequest, DEFAULT_ENCODING);
        req.end();
        req.on('error', function(e) {
            console.log('Problem with request: ' + e.message);
            return;
        });
    }


  /*  function placeBet(options, response, marketId) {
        var str = '';
        var selectionId  = retrieveSelectionId(response);
        // Invalid price and size, change that to minimum price of 2.0
        var price = '2';
        var size = '0.01';
        var customerRef = new Date().getMilliseconds();
        console.log("Place bet on runner with selection Id: " + selectionId);
        var requestFilters = '{"marketId":"'+ marketId+'","instructions":[{"selectionId":"' + selectionId + '","handicap":"0","side":"BACK","orderType":"LIMIT","limitOrder":{"size":"' + size + '","price":"' + price + '","persistenceType":"LAPSE"}}],"customerRef":"'+customerRef+'"}';
        var jsonRequest = constructJsonRpcRequest('placeOrders', requestFilters );
        var req = https.request(options,function (res){
            res.setEncoding(DEFAULT_ENCODING);
            res.on('data', function (chunk) {
                str += chunk;
            });
            res.on('end', function (chunk) {
				var response = JSON.parse(str);
				handleError(response);
                console.log(JSON.stringify(response, null, DEFAULT_JSON_FORMAT));
            });
        });
        req.write(jsonRequest, DEFAULT_ENCODING);
        req.end();
        req.on('error', function(e) {
            console.log('Problem with request: ' + e.message);
        });
    }
*/

    // get event id from the response
    function retrieveEventId(response) {
        for (var i = 0; i<= Object.keys(response.result).length; i++ ) {
            if (response.result[i].eventType.name === 'Soccer'){
                return response.result[i].eventType.id;
            }
        }
    }

    function retrieveCompId(response) {
        for (var i = 0; i<= Object.keys(response.result).length; i++ ) {
            if (response.result[i].competition.name === 'English Premier League'){
                return response.result[i].competition.name;
            }
        }
    }

    // get selection id from the response
    function retrieveSelectionId(response) {
        return response.result[FIRST_INDEX].runners[FIRST_INDEX].selectionId;
    }

    // get market id from the response
    function retrieveMarketId(response) {
        return response.result[FIRST_INDEX].marketId;
    }


    function constructJsonRpcRequest(operation, params) {
        return '{"jsonrpc":"2.0","method":"SportsAPING/v1.0/' +  operation + '", "params": ' + params + '}'; // , "id":1}'
    }


    // Handle Api-NG errors, exception details are wrapped within response object
    function handleError(response) {
        // check for errors in response body, we can't check for status code as jsonrpc returns always 200
		if (response.error != null) {
            // if error in response contains only two fields it means that there is no detailed message of exception thrown from API-NG
            if (Object.keys(response.error).length > 2) {
                console.log("Error with request!!");
                console.log(JSON.stringify(response, null, DEFAULT_JSON_FORMAT));
                console.log("Exception Details: ");
                console.log(JSON.stringify(retrieveExceptionDetails(response), null, DEFAULT_JSON_FORMAT));
            }
			process.exit(1);
		}
	}

	// Get exception message out of a response object
	function retrieveExceptionDetails(response) {
		return response.error.data.APINGException;
	}
}
